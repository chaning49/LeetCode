## 2140. Solving Questions With Brainpower
### 문제 설명
- 0으로 시작하는 2차원 배열 questions가 주어지고, questions[i] = [pointsi, brainpoweri]이다.
- 배열은 문제를 순서대로 처리하고(예: 0번 문제부터 시작) 각 문제를 풀지 건너뛸지 결정해야 하는 시험 문제를 설명한다. i번째 문제를 푸는 것은 당신에게 포인트를 줄 것이지만 당신은 다음 브레인 파워 문제를 각각 풀 수 없을 것이다. 질문 i를 건너뛰면 다음 질문에 대한 결정을 내릴 수 있다.
- 예를 들어 questions = [[3, 2], [4, 3], [4, 4], [2, 5]]이 주어졌다고 가정한다.
- 만약 0번째 문제를 풀었다면 당신은 3 포인트를 얻게되지만 1번과 2번 문제를 풀 수 없다.
- 대신 0번째 문제를 건너뛰고 1번 문제를 풀었다면 4 포인트를 얻게 되지만 2번과 3번 문제를 풀 수 없다.
- 시험에서 얻을 수 있는 최대 점수를 반환해라.
​
### 문제 해결 과정
- 시간복잡도 상으로는 O(N)까지 허용된다. for문 하나 정도는 가능하지만 그 이상은 어렵다.
- dp로 풀었을 경우, 스킵하는 경우를 따져보고 최대값을 찾아볼 수 있을 것 같다!
- **또 답봄 ^^**
- 이 문제는 questions의 길이 + 1의 dp를 새로 생성해준다. dp의 마지막부터 맨 처음까지 순차적으로 돌면 dp[0]이 최댓값(정답)이 되며 스킵하는 경우와 스킵하지 않는 경우를 dp에서 모두 체크해줄 수 있다.
- Example1을 기준으로 설명한다.
- dp[n + 1]은 dp[5]이므로 dp의 공간은 총 5개이다. [0, 0, 0, 0, 0]에서 questions의 맨 마지막 point가 2일 때, 해당 문제를 skip하면 0, solve하면 2가 되어야 한다. 대신 정답을 저장할 때는 index - 1의 위치에 저장해야 한다. 그 이유는 dp의 마지막은 모두 skip한 경우를 따져주는 것이기 때문이다.
- 그 다음으로 인덱스를 하나 빼주면 point가 4이고, 해당 문제를 skip하면 그대로 2가 되고, solve하면 4가 된다.
- 그렇게 순차적으로 dp를 채워가면 최종적으로 배열 dp = [5, 4, 4, 2, 0]이 된다. 즉 dp의 첫 번째 값이 항상 최대값이 된다.
​
- 여기서 nextQuestion = Math.min(n, i + brainPower + 1)인 이유는 다음 문제를 푸는데 소요되는 brainPower를 고려해야 하기 때문이다. 만약 i번째 문제를 solve한다면 그 다음 brainPower개의 문제를 skip해야 하기 때문이다. 그렇기 때문에 i번째 문제를 푼 경우 i + brainPower + 1이 풀 수 있는 다음문제가 된다.