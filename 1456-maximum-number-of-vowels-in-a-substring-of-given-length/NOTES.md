## 1456. Maximum Number of Vowels in a Substring of Given Length
### 문제 설명
- 문자열 s와 정수 k가 주어지고, 길이가 k인 s의 substring 내에 포함된 모음의 최대 개수를 반환해라.
- 영어의 모음은 'a', 'e', 'i', 'o', 'u'이다.
​
### 문제 해결 과정
- 길이가 최대 10^5이므로 시간 복잡도는 최대 O(n)정도로 맞춘다고 생각하자.
- s의 앞에서부터 모음인 경우를 체크해본다. 그 다음 k만큼 잘라서 순회하면 정답이 나올듯!
- TC가 돌아가고 있다. 일단 로직을 설명해보자!
- 문자열 s를 하나씩 순회하면서 1과 0으로 구성된 새로운 문자열을 만든다.
- 각 자리마다 모음이면 1, 아니면 0을 붙여준다.
- substring으로 k만큼 잘라서 모음이 몇 개 있는지 확인하기 위해 countVowel을 돌려주고, 최대값인지 계속 비교해준다.
- 시간초과 이슈가 발생했다. countVowel 때문인 것 같다. 해당 부분의 시간을 줄이기 위해서 다른 방법을 찾아봐야 할 듯
- 슬라이딩 윈도우를 사용하는 문제라고 해서 공부 살짝 하고 돌아옴
- 모음을 판별하는 isVowel을 통해 1과 0을 반환받을 수 있도록 한다.
- 모음 개수의 최대값을 저장할 maxNum과 움직이면서 k칸 만큼의 합을 저장할 currNum을 선언한다.
- currNum에 i에 해당하는 문자가 모음이면 1을 더하고, 아니면 0을 더한다. 만약 i가 k 이상이 되면 i - k위치에 있는 값을 빼줘야 하는데, 그 이유는 한 칸씩 움직이고 있기 때문에 currNum에서 이전에 더했던 값을 빼고 현재 더해줘야 하는 수를 더해주면 매번 새롭게 구간합을 구할 필요가 없기 때문이다.
- 말로 쓰려니 어렵다 뭔소린지 나도 모르겠음.
- currNum에 i에 해당하는 문자가 모음이면 1을 더하고, 아니면 0을 더한다. 만약 i가 k 이상이 되면 i - k위치에 있는 값을 빼줘야 하는데, 그 이유는 한 칸씩 움직이고 있기 때문에 currNum에서 이전에 더했던 값을 빼고 현재 더해줘야 하는 수를 더해주면 매번 새롭게 구간합을 구할 필요가 없기 때문이다.