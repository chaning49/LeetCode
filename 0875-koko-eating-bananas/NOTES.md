## 875. Koko Eating Bananas
### 문제 설명
- 바나나를 좋아하는 Koko가 있고, 바나나로 된 piles가 있는 piles 배열이 있다. piles를 지키는 가드는 자리를 비웠다가 h시간 후에 돌아온다.
- Koko는 한 시간에 k속도로 바나나를 먹을 수 있다. k속도보다 작은 바나나를 먹으면 먹는 동안에는 바나나를 더 먹을 수 없다.
- h시간 내에 모든 바나나를 다 먹을 수 있는 k의 최소값을 찾아라.
### 문제 해결 과정
- 어제 풀었던 문제와 유사해보인다. 배열에서 정답을 찾는 것이 아니라 k값을 찾아야 하기 때문이다.
- 찾아야하는 k의 범위는 1~pilles의 최대값으로 시작해서 이진 탐색으로 해보면 되지 않을까? 해보고 다시 생각해보자.
- piles[i]보다 k가 커질 수 있는 n을 찾고, 각 n의 합이 h와 같은 최솟값을 찾는 것일듯! (맞았다!)
- 중요한 것은 각 배열을 k(mid)로 나누었을 때, 몫을 더하고 나머지가 있다면 +1 해주는 것이 필요한 k의 개수를 정확하게 알 수 있다는 것이다.
- end를 배열의 최댓값 * 배열의 길이로 설정했는데, 배열에 들어갈 수 있는 최댓값이 10억이기 때문에 자료형이 int임을 고려하여 배열의 길이를 빼주어야 한다. 빼줘도 정답이 잘 나옴!

![알고리즈무-21](https://user-images.githubusercontent.com/79316402/223693360-48bc9548-6b42-48a5-8fdb-cdd424353a59.jpg)
